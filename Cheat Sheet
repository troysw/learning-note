# Cheat-sheet

스프링부트 (Spring boot)

스프링 컨테이너 (IOC)

쉽게말해 제어의 역전,

- 스프링이 heap영역을 제어함
	그래서 내가 스택안의 지역변수들을	
	매번 만들 필요없이 어노테이션을 붙여서
	스프링컨테이너에 인식을 시키면
	알아서 스프링이 만들어준다.

IOC를 따르기 위해서
패키지 파일을 ioc 규칙에 맞게 설계해야함

------------------------------------------------------------------------------


Spring / Update / dirty checking

@Transactional 어노테이션을 걸고
영속성 컨텍스트에 자료를 넣어두면
.save 를 하지 않아도 트랜잭션이 종료 되기 직전 
영속성 컨텍스트와 실제 DB의 차이를 스프링에서 인식하고 

업데이
업데이트가 된다

이걸 더티체킹이라고 함

------------------------------------------------------------------------------

깃 ( Git, Github )

깃은 특정 시점 , 특정 장면을 하나 씩 저장하고 볼수 있는것

깃의 3가지 영역

작업영역 , 인덱스 영역 , 헤드 영역

이 세가지를 일치시키는게 깃이다

무언가 일치시킨다 = 동기화

작업영역 = (흐르는 뷰) 에서
add 를 시키면

인덱스 = 사진 에서
commit 을 시키면

헤드 = 사진첩

사진첩인 헤드에서 이전 작업으로 시간을 돌리고 싶으면

타임라인 순으로 되있어서 돌아가는 게 가능함


------------------------------------------------------------------------------

http 1.1 

http 통신 은 약속(프로토콜)이다

클라이언트 = 배고픈 사람 = 요청하는 사람

통신방법 (요청,request) 4가지

get = 데이터를 줘! (Select)\
		get 방식으로만 인터넷 브라우저를 불러올수 있고
		어떤 데이터를 요청할 건지 요청하는 방법은 쿼리스트링 밖에없다
	
		
특징 : body로 데이터를 담아 보내지 않음 //주소(헤더)에 데이터를 담아서 보내는것//그래서 무슨데이터를 보내는지 다 보임//
나머지 3개는 데이터를 변경하는 요청임
	- 데이터를 담아보내야 할 것이 많다.
	- 회원가입만 해도 주르륵 있음
	- 

post =  데이터를 추가해 줘! (Insert)  
		클라이언트가 데이터를 입력(회원가입처럼)해서 던져줌!

put = 데이터를 수정해 줘! (update) -> DB row 전체를 갈아 치우는 것이 때문에 필요한 경우에 쓰는 것이 베스트~
patch = 데이터를 "일부만" 수정해줘! (update) -> DB row 한줄을 전부 바꾸는 것이 아닌 경우에 쓰면 효율적

delete = 데이터를 지워 줘! (delete)

------------------------------------------------------------------------------



http는 기본적으로 문서 전달을 기준으로 만들어진 방식임

그 문서란 -> 특정한 약속 
ex)) ? 뒤에는 데이터다, 고로 파싱해야한다 따위의 약속



------------------------------------------------------------------------------


stateless 와 statefull


Stateless = 요청시 마다 스트림을 연결해서 데이터를 주고받는 방식
			http 가 이 방식을 씀

Statefull = 연결이 지속되있는 방식 
			(채팅같이 데이터 실시간 연결)

세션을 만들다 = 데이터를 응답해줄 준비가됨 (인증이 됨)

http는 stateless라서 연결이 끊기면 세션을 끊어야되서

이걸 어떻게 유지할 것인가가 중요


2022 / 05 / 10 -> 아직 제대로 된 이해 



------------------------------------------------------------------------------

MIME(마임) 타입

패킷으로 데이터를 보낼때 바디에 들어갈 데이터의 타입 형식이란 뜻

POST요청은 여기에 대한 ~~ 데이터를 추가! 해줘 라는 뜻인데

이걸 어디에 담냐면 요청시에 헤더와 바디 라는 걸 달고 요청을 감

내 사진이 MY.JPEG 라고 치면

헤더에 : IMAGE/JPEG

바디에 : MY.JPEG 가 들어감

바디에는 실질적 데이터

헤더에는 데이터를 설명해주는 내용이 있어야함


HTTP 통신을 쓸대 우리가 쓰느 ㄴ방식은

패킷 스위칭 = 데이터를 하나하나 쪼개고 그것을 패킷이라고 함
				그걸 한개씩 전송함

				패킷스위칭 을쓰면 C라는 사용자가 데이터를 보내도
				같은 선을 이용함
				받는 서버 쪽에서 각각 사용자의 데이터를 조립함
				
				데이터는 전선을 이용해 들어오는데
				패킷 경우엔 3개의 데이터를 보내면 각자가
				다른 속도로 누가먼저 도착할지 몰라서
				모든 패킷에는 헤더가 붙어있음
				
				헤더에 순서, 보낸 사람이 누군지 식별자가 
				붙어있어서 정리가능
				
				바디에는 실질적 데이터가 들어가는것
				바디 데이터의 타입은
				TEXT일수도, 이미지 일수도 AVI일수도있기때문에
				MIME타입을 공부해야 설정을 해서 보낼수 있음
			
서킷 스위칭 = A와 B가 데이터를 교환할때
				데이터를 한방에 올려서 전송함
				속도는 빠르지만 선이 물리적으로 많이 필요함

------------------------------------------------------------------------------

자바(Java)

자바에서 변수를 private 으로 만드는 이유는?
	직접 변수를 변경하는걸 막기위해서.
	변수를 메서드에 의해 변경이 되도록 만들어야
	객체지향임
	변경하는 메서드 = 게터 세터

------------------------------------------------------------------------------

메이븐(Maven)

프로젝트 관리 도구.

pom.xml 에
필요한 라이브러리를 적어만 두면
.m2 라는 폴더에 repository에 다 다운받고 빌드 까지 해주는것

------------------------------------------------------------------------------

롬복 (Lombok)

어노테이션을 추가해주는 편의기능 라이브러리

NoArgsConstructor
	빈 생성자 만드는 어노테이션

AllArgsConstructor
	필드값 다 가진 생성자 만드는 어노테이션

Builder
	필요한 필드 값만 따로 가져올수 있게 만드는 어노테이션
	순서 안지켜도 됨
	직접 만들면 생성자 만든 순서 대로 해야됨
	ex) Member.builder().username~~~.build();

Data 
	게터 세터 다만들어주는 어노테이션

Getter
	게터만 만들어줌
Setter
	세터만 만들어줌


------------------------------------------------------------------------------

Yaml ( yml ) 파일

name: kim

이런식으로 키값에 :를 붙이고 스페이스로 한칸 띄고 밸류 입력 ( 규칙 )

하위 로 만들려면 들여쓰기 규칙 -> 스페이스 2칸 (규칙)


------------------------------------------------------------------------------

root-context 파일

스프링 레거시 쓸때 나오는 파일

데이터베이스 설정 파일임

1번만 new 되고 더이상 new 될 필요 없는 파일들 ( 싱글톤 관리가능한)

------------------------------------------------------------------------------

servlet-context 파일

스프링 레거시 쓸때 나오는 파일

지속적으로 계속 new 해서 만들어 사용해야되는 애들 설정하는 파일

------------------------------------------------------------------------------

도메인(domain)

도메인이라는건 어떤 범위를 이야기함

성별이라면 도메인은 남녀

학년이라는게 있다면 도메인은 고등학교면 1~3 인 것 처럼.

이뜻은 넓은 의미로 쓰임.

커다란 맥락 안의 범위 일수도, 학년 같이 작은 범위 일수도 있는것 같음.


------------------------------------------------------------------------------

ORM

자바 뿐 아니라 모든 언어들 오브젝트를 테이블로 매핑해주는 것을 말함

대표적인게 jpa 임



db 는 오브젝트를 저장할 수없다,
자바는 오브젝트를 저장할 수 있으므로 fk를 안써도됨

orm을 쓰면 오브젝트 형태로 저장을 할 수 있음


게시글 상세보기 같은경우에는
마이바티스 같앗으면

여러 db 테이블을 조인해서 셀렉트를 해서 
해당 페이지의 데이터를 들고 왔겠지만

orm 은 board 테이블만 셀렉트하면 됨

예를 들어
jpa 나 orm 프로그램은

자바 <--> JPA(ORM) <--> DB 과정에서

select * from Board where id = 1  이라고 셀렉트 하면
board id 1 번을 가져올때 
자동으로 userId라는 조인한 fk 키를 보고 
자동으로 jpa 에서 db로 갈때 조인문을 날림

그래서 결국 응답 받을때

보드 테이블을 가져와도 조인된 user 테이블의 정보도 자동으로 가져옴

거기에 reply 정보도 있으면 3개다 조인해서 돌려줌

하나의 게시글은 하나의 유저만 쓸수 있고
그 하나의 게시글에는 여러개의 댓글이 나올 수 있음

여러개의 댓글이 나올수 있어야 하므로 "리스트"로 댓글을 받아야됨
그러나 그대로 끌고 오면 에러남 ( 원자성 법칙 )
그래서 mappedby 로 연관관계주인이 아니라는걸 알려주고
몇개가 나올지 모르므로 fetchtype 은 lazy


결국

상세보기 페이지를 볼때
작성자 이름이 필요하므로 userId -> fetchtype.EAGER
댓글이 보여야하므로 Reply -> fetchtype.LAZY(필요할때 떙겨온다)


근데!!!

결국 상세보기 페이지를 볼때 한번에
댓글도 나와야 하므로 ?
reply fetch type 도 EAGER로 끌고 와야한다

------------------------------------------------------------------------------

JPA


many to one = 기본 fetchtype = EAGER 무조건 들고오라는뜻

many = board
one = user

한명의 유저는 여러개의 글을 쓸 수 있다

여러개의 게시글은 한명의 유저에게 쓰일 수 있다.


One to one 
한명의 유저는 한개의 글밖에 쓸 수 없다

one to many = fetch type = Lazy 필요하면 가져오겠따

연관관계의 주인
	fk를 누가 가졌느냐. fk를 가진 오브젝트

many to many 


------------------------------------------------------------------------------

JSON

프로그램언어의 공용어(실제언어로 치면 영어) 같은 것이다.
자바 오브젝트를 -> json에 태워서 -> 파이썬으로
      전송(한국어)    -> 영어 ->   응답(일본어)

한마디로 데이터통신(언어간 쉬운 번역)을 위한 중간 데이터(공용어인 영어)가 되는 것이다.

통신을 할때 자바 오브젝트를 json 데이터로 바꾼다는건
전송을 한다는 것이고 반대는 응답이다.

@Controller 에서 요청 ( request) 오는 바디데이터를
전부 json으로 받을 것

반대로 response 응답 할때도 json 으로 받을것

------------------------------------------------------------------------------

Enum 

enum은 도메인을 만들때 쓴다.

어떤 범위 안의 데이터를 넣을때

ex) 남 , 녀

------------------------------------------------------------------------------

회원가입시 ajax로 사용하는 이유

1 요청에 대한 응답을 html 이 아닌 Data(json)으로 받기 위해서

2 비동기 통신을 하기 위해서
	. 비동기 통신이란?
	 프로그램은 원래 순서대로 작동한다
	(다운로드를 기다리는것을 pending 이라고함)
	프로그램 작동 절차중 뭔가 다운로드를 하는거는
	램과 hdd 가 하는 것이고
	나머지는 cpu가 함

	비동기 처리는 일에 순서에 상관없이 절차를 실행 함
	
1번 이 실행
2번 이 실행
3번은 ram    

	
------------------------------------------------------------------------------

DTO 와 VO

DTO

데이터 트랜스퍼 오브젝트

데이터 옮길때 쓰는 바구니

컨트롤러 -> 서비스 -> 엔티티

머 이런식으로 옮길때 쓰이는게 DTO 다

게터 와 세터 메서드만 가지고

다른거는 가지지 않는다





VO

VALUE OBJECT

값 그 자체를 표현하는 객체

= 돈 , 만원 마다 각자의 고유 번호가 있따

세터를 포함하지 않는게 좋다 ( 마음대로 변경을 하지 않기 위해서)

생성자를 통해서만 값을 초기화 함






ENTITY

데이터베이스와 매핑 되어 있는 핵심 클래스
절대 요청이나 응답값을 사용 하면 안됨

엔티티 클래스를 기준으로 테이블 생성, 스키마 변경


------------------------------------------------------------------------------

@RequestBody

HTTP 요청의 body 내용을 자바 객체로 매핑하는 역할

@ResponseBody 어노테이션
자바 객체를 HTTP 요청의 body 내용으로 매핑하는 역할

------------------------------------------------------------------------------

Hash 암호화

안녕 -> 해쉬 암호화 -> 고정길이의 16진수값으로 변경됨
안녕! -> 해쉬 암호화 -> 완전다른 고정길이의 16진수값으로 변경됨

300페이지 의 책도 고정 길이의 임의의 문자열으로 바뀌는데

페이지 중 1개만 바껴도 문자열이 바뀌기 때문에

최초 300페이지의 암호화된 문자열이 있으면

중간에 누가 바꿔서 내는지, 위조인지 아닌지 알 수 있다

------------------------------------------------------------------------------

csrf, xss

xss = 자바스크립트로 게시판을 공격하는것

csrf = href 로 공격하는건데 이걸 막으려면 

아예 post로 데이터를 주고 받던가

사용자 세션에 csrf 토큰을 setAtrribute 로 주고

이동할때마다 토큰이 맞는지 보던가 해야함

------------------------------------------------------------------------------
security 용어

Principal -> 주체

사용자(user) , 디바이스 , 시스템 등 행위를 하는 어떤 주체 라는 뜻


------------------------------------------------------------------------------

Optional<T>


Optional<T>는 null이 올 수 있는 값을 감싸는 Wrapper 클래스로, 
참조하더라도 Null poniter Exception ( NPE ) 이 발생하지 않도록 도와준다. 
Optional 클래스는 아래와 같은 value에 값을 저장하기 때문에 
값이 null이더라도 바로 NPE가 발생하지 않으며, 
클래스이기 때문에 각종 메소드를 제공해준다.

------------------------------------------------------------------------------

security 수순

SecurityConfig 파일 을 만들어서 내부 작성하고

로그인이 감지 되면 ?

http .formLogin() 작동 되면서 

로그인 하는 url 를 시큐리티가 뺏어가서 실행하는데

principalDetailService 에서

loadUserByUsername(String username) 이란 메서드에 던지면
(미리 오버라이드 해서 유저네임이랑 패스워드 encoding
작성해놔야함)

유저네임이 저기 스트링으로 들어가고

레파지토리에 실제로 존재하는 username 인지 확인하고
(비번 확인은 안보이는데서 따로 실행되고)

그게 성공적으로 되서
return principal 을 리턴 할때 
시큐리티 세션에 유저 정보가 저장이 되고

로그인이 됨







/logout 이라는 url은 시큐리티가 지정해놓은 디폴트 값임



------------------------------------------------------------------------------

스프링 부트

작동원리 전반적 흐름 



톰켓이 시작됨
▼
필터 들이 메모리에 올라옴
▼
디스패쳐
(사용자들이 url 친거 ex) / , /admin, /user
이 주소를 확인해서 적절한 컨트롤러한테 요청함
▼
리퀘스트 요청이 들어오면?
▼
컨트롤러가 메모리에 뜸
▼
서비스가 메모리에 뜸
▼
JPA레파지토리가 메모리에 뜸
▼
영속성 컨텍스트 가 메모리에 뜸

사용자 요청이 올때마다 컨트롤러 서비스 jap 영속성이

새로운 쓰레드를 하나씩 만들어서  뜸

▼
Data source 는 미리 1개만 메모리에 떠있음
데이터 소스는 db랑 직접적인 연결이 되어있음

▼
뷰 리졸버, 인터셉터도 미리 메모리에 떠 있음



시나리오 1개 대충 해보자면


사용자가 로그인 요청
▼
당연히 톰캣, 디스패처, 필터들은 켜져있을 것
▼
디스패처가 로그인 요청을 확인 ( localhost:8000/login) 이

post 요청으로 왔다면

http바디에 유저네임 패스워드가 요청이 날라 올 것임

그럼 디스패처가 /login이라는 post매핑이 된 

컨트롤러를 찾으면 그 컨트롤러가 

유저네임과 패스워드를 컨트롤러가 받음

컨트롤러는 받는거 밖에 안하는 몽총이 이기 떄문에

이제 서비스로 넘겨주면서

로그인을 해달라! 라고 서비스한테 요청(request)를 하는거임

▼


서비스에서는 로그인을 하기 위해 DB에 질문을 함(SQL)

이 유저네임과 패스워드를 가진 사용자가 있읍니가..? 하고 물어봐야함

근데

이 질문을 JPA 레파지토리 한테 해달라고 요청함

SELECT "해줘"

▼

JPA 레파지토리는 

자기가 들고 있는 함수를 호출할 것임

머 예를 들면

쿼리를 불러 온다던가

SELECT * FROM USER 
WHERE USERNAME = ? 
AND PASSWORD= ?

이 거를 호출 해와서


유저테이블에  아까부터 가져온 유저네임과

패스워드가 일치하는 녀석이 있다면?

영속성 컨텍스트한테

유저라는 오브젝트가 영속성 컨텍스트 너 안에 존재하니?

라고 물어 봄

최초 요청이면 당연히 있을리가 없음

▼

그럼 영속성 컨텍스트가 데이터소스 한테

야 ㅋㅋ 니가 db한테 물어바바 ㅋ 하고 쫄름

▼

그럼 데이터 소스가 DB 한테 실질적으로 물어봄

▼

db가 직접 검색을 함

SELECT * FROM USER 
WHERE USERNAME = ? 
AND PASSWORD= ?


해서


데이터소스한테 응답을 해주는데

SELECT * FROM USER 라고 했기때무네

모든 유저 오브젝트 들을 데이터 소스한테 일 단 다줌


▼

그럼 데이터 소스가 영속성 컨텍스트 한테

다시 돌려줌

▼

이때 영속성 컨텍스트한테

해당 유저에 대한 오브젝트가 만들어짐

▼

유저 오브젝트 가 만들어졌으니

그거를 jpa 레파지토리한테 돌려줌

▼

레파지토리가 그러며는

다시 서비스한테 유저 정보를 돌려줌

▼

그러면 서비스는 ?

유저가 일단 null인지 아닌지 확인

null 이면 당연히 로그인 안될거고

null 이 아니면

컨트롤러 한테 유저 맞다고 알려주고

세션에 유저 정보를 등록 해놓거나 

하는걸 서비스에서 알아서 잘 짜놓으라 이말이야...

▼

컨트롤러는 그러면

다시 뭐 메인페이지를 리턴 해주거나 하는데

이떄!!!!

컨트롤러가 RestController 면 ?

데이터를 응답 하는 컨트롤러 지만

그냥 Controller 면

html 페이지를 응답해주는 컨트롤러 기 때문에

그때는?

뷰 리졸버가 작동함

뷰 리졸버는 페이지를 만들어서 응답 해줌

예를 들어 return home;

이면 리졸버가 home이라는 페이지를 프로젝트를 뒤져서 찾음

home이 jsp 면 html로 만들어서 응답해줌


RestController 면?

그냥 home 이라는 텍스트를 응답 해버림

말그대로 데이터를 리턴하는 컨트롤러 기 때문에






------------------------------------------------------------------------------


Oauth2.0

Oauth -> open auth -> 인증처리를 대신 해준다


카카오로그인 버튼을 누르면 다이렉트로 카카오한테 로그인 요청을 하는 것임

카카오로그인을 하고 동의 창 체크를 하면

카카오 측에서 우리한테 콜백 데이터 코드를 줌 (코드는 임의임)

그걸 받으면 인증처리 완료 


------------------------------------------------------------------------------


JWT CorsFilter

Security config 만들때

jwt 에서는 세션을 없애고 스테이트리스 로 써야함

corsFilter를 만들어서 Config에 추가 해도 되고

@CrossOrigin을 써도 되지만


크로스 오리진은 인증이 없을때 쓰는것

------------------------------------------------------------------------------

JWT Config

httpBasic().disable() 의 뜻


클라이언트에서 id , pw 를 보낸 최초 요청이 일어나면 서버는 세션 메모리 영역에 세션 id 를 만듬

A라는 유저가 있으면 A 의 세션 id 를 만들고 A만의 영역을 만들어놓음

id , pw 가 정상이면 A만의 세션영역에 해당 user 오브젝트를 저장하고

응답을 세션 id를 리턴 해주는데 클라이언트인 웹브라우저는

쿠키 영역에 자동으로 세션 id 를 저장을 함

그 후에 새로운 요청이 일어나면 그 쿠키에 있는 세션 id 를 같이 들고 요청을 함

그럼 서버 세션에서는 그 쿠키 세션 id 를 보고 같은지 확인 하는 방식임.


이 방식의 안좋은 점은 

서버가 1개일때는 괜찮으나

서버가 여러개 일때는 확장성이 굉장히 안좋음

또 동일한 도메인 안에서만 작동함

도메인 밖에서 ( js 써서 ) 요청을 넣으면 자동으로 거부함

http only 라는 설정을 풀면 되지만 그러면 보안이 갱장히 안좋아짐


그래서?

header에  authorization 키 값에

인증 정보를 넣고 가는 방식이 있는데

저 authorization 에 id, pw 를 담아서 같이 요청을 보내는게

http basic 방식 임

이렇게 되면 매번 id pw 를 달고 요청하는거라 굿인데

서버측 도메인이  http 라면 저 authorization에 보안이 없음 ( 암호화가 안됨 )

https 의 경우는 노출이 안되게 암호화를 해서 요청 해줌 
https 의 s 는 secure 라는 뜻이기 때문..



JWT 는 이 authorization 에다가 토큰이라는걸 넣어서 인증하는 방식임

토큰은 노출이 되어도 토큰 자체가 id랑 pw가 아니고

토큰은 로그인할때마다 서버측에서 매번 새로 만들기 때문에

""비교적"" 노출되어도 위험이 조금 적다.

아직 안배웠지만 아마 이것때문에 리프레시 토큰을 쓰는것 같기도..


여튼

이방식을 Bearer 방식이라고 함


저 토큰을 json web token 으로 쓸것이기 때문에

Security config에

세션방식 도 안쓰고

form태그 로그인도 안쓰고

http basic 도 안쓴다고 선언 ,,!


------------------------------------------------------------------------------

JWT , 필터 (Filter)



필터는 내가 만든것 보다 항상 security 필터가 먼저 작동 되기때문에

security 필터 이전에 작동하게 하고싶은 필터가 있다면

Security Config 에

http.addfilterBefore를 쓰자

http.addFilterBefore(new 내필터(), SecurityContextPersistenceFilter.class);

라고 해버리면 서버 실행 되고 가장 빠른 필터가 됨~


------------------------------------------------------------------------------

JWT 토큰


토큰 원리는

사용자가 올바른 로그인시 -> 토큰을 만들어줌

요청 할때마다 헤더에 authorization에 

value값으로 토큰을 가지고 오고

토큰이 넘어 오면 이 토큰이 내가 만든 토큰인지 rsa, hs256 등등 으로 검증

------------------------------------------------------------------------------

